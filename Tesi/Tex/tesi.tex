\documentclass[12pt]{article}
\usepackage{amsfonts}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{geometry}
\usepackage{helvet}
\geometry{margin=1in}
\newcommand*{\N}{\mathbb{N}}
\title{ \LARGE\textbf{New Online Algorithms for Story Scheduling in Web Advertising}}
\date{}
\begin{document}
\maketitle
\section{Introduzione}
L’ambito di studio è lo storyboarding in cui gli advertisers desiderano presentare sequenze di ads (storie) senza interruzioni su una posizione di rilievo di una pagina web. Queste storie/jobs arrivano “online” e vengono attivate in base alla cronologia di navigazione dell'utente che, in ogni momento, continua a navigare con probabilità $\beta$. Nello storyboarding un singolo advertiser controlla una posizione pubblicitaria di rilievo per un certo continuativo periodo di tempo. L’advertiser crea una storia pubblicizzando i propri prodotti e la mostra utilizzando gli slot di tempo a lui concessi. Tipicamente molti advertiser competono per tale posizione. L’obiettivo di un ad server è quello di costruire uno schedule che massimizzi il risultato aspettato.

Formalmente lo storyboarding è stato formulato come un problema di scheduling di jobs online da Dasgupta, Ghosh, Nazerzadeh e Raghavan in una precedente pubblicazione [1]. Consideriamo un utente che al tempo $t = 0$ inizia una sessione web. Il tempo è “slotted”. In qualsiasi momento l’utente continua a navigare con probabilità $\beta$ e smette di navigare con probabilità $1 - \beta$ con $0 < \beta \leq 1$. Quindi il tempo di navigazione è una variabile casuale geometrica (distribuzione geometrica). Nel tempo le storie (jobs) arrivano online. Ogni job $i$ è specificato da un tempo di arrivo $a_{i}$, una lunghezza $l_{i}$, che rappresenta la lunghezza della storia, e un valore per unità $v_{i}$, che rappresenta il premio ottenuto dal server mostrando un unità del job $i$. Considerando tutti i jobs in arrivo si ottiene un'istanza del problema $I = (a_{i}, v_{i}, l_{i})_{i=1}^{N}$ con  $N \in \N \cup \{ \infty \}$

Uno schedule $S$ per $I$ specifica quali job processare ad ogni tempo $t \geq 0$. $S$ può anche non contenere tutti i job di $I$, è infatti permesso tralasciare dei job non desiderati. $S$ è ben definito se ogni job schedulato è processato a tempi $t \geq a_{i}$ per al massimo $l_{i}$ unità di tempo. Inoltre il pre-rilascio dei jobs è permesso, cioè un job $i$ può essere processato per meno di $l_{i}$ unità di tempo. In questo caso non si può ottenere valore per la porzione pre-rilasciata non schedulata di un job. 
Dato uno scheduler $S$, il suo valore è definito come il valore atteso $\sum_{t=0}^{\infty} \beta^{t}\cdot v(t)$ dove $v(t)$ è il valore per unità del job schedulato al tempo $t$. Sia $ALG$ un algoritmo online che, dato qualsiasi input $I$, costruisca uno schedule di valore $ALG(I)$. Sia $OPT(I)$ il valore di uno schedule ottimale offline per $I$. Si dice che $ALG$ è c-competitivo se esiste una costante $\alpha$ tale che $c \cdot ALG(I) + \alpha \geq OPT(I)$, $\forall I$ [2].
\section{Lavori precedenti}
Secondo questa pubblicazione, lo storyboarding è stato studiato, da un punto di vista algoritmico, solamente da Dasgupta et al. [1]. Una prima osservazione è che se $\beta  = 1$ allora il problema è semplice da risolvere in quanto il valore dello schedule non dipende dal tempo in cui vengono eseguiti i vari job. Quindi ci si concentra nel caso in cui $0 < \beta < 1$.
Dasgupta et al. [1] hanno mostrato che nessun algoritmo deterministico online può avere un rateo competitivo di $\beta + \beta^{2}$ che quindi è limitato superiormente da 2. Come risultato principale Dasgupta et al. hanno sviluppato un algoritmo greedy che è 7-competitivo. Inoltre hanno affrontato un’estensione del problema in cui i jobs hanno un valore per unità crescente anziché costante e in cui il valore è ottenuto solo quando il job è completamente finito. Infine hanno studiato un’altra estensione del problema in cui un job dev’essere schedulato immediatamente all’arrivo, altrimenti è perso.

\section{Contributi di questo articolo}
Gli autori di questa pubblicazione hanno presentato tre nuovi algoritmi online per lo storyboarding. Tutte le strategie seguono il paradigma del processare una data sequenza di job $I$ in fasi, in cui una fase consiste in k intervalli di tempi consecutivi per qualche $k\in \N$. 
Sia $k \geq 1$ un intero, una k-fase consiste in k intervalli di tempo consecutivi. Nello specifico l’n-esima k-fase $P_{n}$ è la sottosequenza di intervalli di tempo $(n-1)k,…,nk - 1$, per ogni $n \geq 1$. All’inizio di ogni fase un algoritmo crea uno schedule per la fase, ignorando i job che potrebbero arrivare durante la fase. In questo modo le decisioni di scheduling vengono prese una volta ogni tanto.

Il primo algoritmo presentato crea uno schedule ottimale per ogni fase e pre-rilascia i jobs che non hanno finito la loro esecuzione alla fine della rispettiva fase. Viene dimostrato che il rateo competitivo di questa strategia è esattamente $1/\beta^{k-1}\cdot(1-\beta^{k}), \forall \beta$ e $\forall k \in \N$. Inoltre con la migliore scelta di k si ottiene una competitività di $4/(2 - \beta)$ che è limitata superiormente da 4, $\forall \beta$ e $\forall k \in \N$. Infine se scegliamo $k = 1$, l’algoritmo risultante è $1/(1-\beta)$ competitivo e tale scelta permette di ottenere migliori limitazioni della competitività per $\beta$ piccoli, cioè per $\beta < 2/3$.

Il secondo algoritmo presentato è una raffinazione del primo algoritmo che preferisce non pre-rilasciare i jobs che non hanno terminato alla fine della rispettiva fase ma invece prova a rieseguirli nella fase successiva. Il rateo competitivo di questa strategia è limitato superiormente da $1/\beta^{k-1} \cdot max\{1/\beta^{k-1}, 1/(1 - \beta^{2k} ), 1 + \beta^{3k}/(1 - \beta^{k} )\}$. Inoltre con la migliore scelta di k, otteniamo un fattore competitivo di $c = 1 + \phi$, dove $\phi = (1 + \sqrt{5})/2$ è la sezione aurea. Si ottiene quindi $c \approx 2.618$ che è molto vicino al limite teorico di 2 presentato da Dasgupta et al. [1] per un $\beta$ generico.

Il terzo algoritmo presentato è una generalizzazione del primo in cui si presuppone che ci siano m macchine parallele (ad positions) disponibili. In questo caso il valore dello schedule creato è dato da $\sum_ {t = 0}^{\infty}\sum_{j = 1}^{m}\beta^{t}\cdot v(t,j)$, dove $v(t,j)$ è il valore unitario del job schedulato sulla macchina $j$ al tempo $t$. Viene dimostrato che, per la migliore scelta di k, il rateo competitivo di questa strategia è $(1 + 1/(1 - \beta(2 - \sqrt{2}))/(2 - \sqrt{2})$. Il rateo è limitato inferiormente da $2/(2-\sqrt{2}) \approx 3.414$ e limitato superiormente da $1/(3 - 2\sqrt{2}) \approx 5.828$.

\section{$ALG1_{k}$}
Il primo algoritmo, chiamato $ALG1_{k}$, crea uno schedule ottimale per ogni k-fase $P_{n}$. Formalmente $ALG1_{k}$ funziona come segue. Diciamo che un job $i$ è disponibile al tempo $t$ se il job è arrivato entro $t$, cioè $a_{i} \leq t$ e non è stato mai schedulato ad un tempo qualsiasi $t’ < t$. Sia $Q_{n}$ l’insieme dei jobs disponibili all’inizio di $P_{n}$, cioè tutti quei job $i$ tali che $a_{i} \leq (n-1)k$. $ALG1_{k}$ ordina i job di $Q_{n}$ in ordine non crescente di valore unitario. I job che hanno lo stesso valore unitario vengono ordinati in ordine crescente di tempo di arrivo. A questo punto $ALG1_{k}$ assegna ad uno ad uno i job ordinati a $P_{n}$, finché tutti i $k$ intervalli di tempo vengono schedulati oppure la sequenza di jobs finisce. Se l’ultimo job schedulato non termina al termine di $P_{n}$, viene pre-abbandonato. $ALG1_{k}$ esegue questo schedule per $P_{n}$, ignorando i jobs che potrebbero arrivare durante la fase a tempi $t = (n-1)k + 1,…, nk - 1$. Per prima cosa valutiamo le prestazioni di $ALG1_{k}$ , per un $k$ generico. Poi determineremo la migliore scelta di $k$. \newline\newline
\textbf{Teorema 1} \textit{ $\forall k \in \N$ e $\forall \beta$, $ALG1_{k}$ è $1/(\beta^{k-1}(1 - \beta^{k}))$-competitivo.}\newline\newline
Di seguito costruiremo le basi per arrivare a dimostrare il precedente teorema. Sia $I=(a_{i}, v_{i}, l_{i})_{i = 1}^{N}$
un input arbitrario. Nell'elaborare $I$, $ALG1_{k}$ rimanda i job che arrivano dopo l'inizio di una fase fino all'inizio della fase successiva. Si consideri un input $k$-quantizzato $I_{k}$ in cui il tempo di arrivo di qualsiasi job è impostato al successivo multiplo intero di $k$, cioè $I_{k} = (a'_{i}, v_{i},l_{i})_{i = 1}^{N}$, dove $a'_{i} =k\lceil a_{i}/k\rceil$. Se $a_{i}$ è un multiplo di $k$ e quindi coincide con l'inizio di una $k$-fase allora il job non viene ritardato. Altrimenti il job viene ritardato fino all'inizio della fase successiva. Lo schedule generato da $ALG1_{k}$ per $I_{k}$ è identico a quello calcolato da $ALG1_{k}$ per $I$. Quindi $ALG1_{k}(I_{k}) = ALG1_{k}(I)$. Al fine di dimostrare il Teorema 1  sarà conveniente confrontare $ALG1_{k}(I_{k})$ con $OPT(I_{k})$. Il lemma successivo assicura che $OPT(I_{k})$ e il vero valore ottimale $OPT(I)$ differiscono al massimo di un fattore  $1/\beta^{k - 1}$.\newline\newline
\textbf{Lemma 1}
\textit{$\forall k \in \N$ e $\forall \beta$, vale la disuguaglianza $1/\beta^{k-1} \cdot OPT(I_{k}) \geq OPT(I)$.}\newline\newline
\textit{Dimostrazione}
Consideriamo uno schedule ottimale per $I$ e spostiamo l'intero schedule di $k - 1$ unità di tempo a destra, cioè il tempo di inizio di ogni lavoro è ritardato esattamente di $k - 1$ unità di tempo. Lo schedule così modificato è corretto per $I_{k}$ perché, per qualsiasi job $i$, il suo tempo di arrivo $a'_{i}$ in $I_{k}$ è ritardato di al massimo $k - 1$ unità di tempo rispetto al corrispettivo $a_{i}$ in $I$. Lo schedule modificato ha un valore di $\beta^{k} \cdot OPT(I)$, e uno schedule ottimale per $I_{k}$ ottiene un valore tanto alto almeno quanto il precedente.\hfill $\square$ \vspace{5mm}

Per stimare OPT($I_{k}$) consideriamo un algoritmo offline ottimale più forte che è stato proposto anche da Dasgupta et al. [1]. Questo algoritmo permette di riprendere l'esecuzione dei job interrotti in un momento successivo. Chiamiamo questa strategia offline $CHOP$. Per qualsiasi input, in qualsiasi istante $t$, $CHOP$ schedula un job che ha il più alto valore per unità tra i job non completati che sono arrivati entro il tempo $t$. Ovviamente, $CHOP(I_{k}) \geq OPT(I_{k})$. Sia $S$ lo schedule calcolato da $ALG1_{k}$ per $I_{k}$ e sia $S^{*}$ lo schedule generato da $CHOP$ per $I_{k}$ . Assumiamo senza perdità di generalità che in $S^{*}$ tutti i job che hanno un certo valore unitario $v$ siano elaborati nello stesso ordine in cui sono processati in $S$. Più precisamente, tutti i job che hanno valore unitario $v$ sono elaborati in ordine crescente di tempi di arrivo. I job di valore unitario $v$ che arrivano nello stesso momento vengono elaborati nello stesso ordine in cui vengono processati in $S$. Lo schedule $S^{*}$ può essere facilmente modificato in modo tale da soddisfare questa proprietà. Per qualsiasi job $i$, diciamo che $t_{S}(i)$ indica il suo tempo di inizio in $S$ e che $t_{S^{*}}(i)$ indica il suo tempo di inizio in $S^{*}$. Se il job i non viene mai processato in $S$ (o $S^{*}$), allora impostiamo $t_{S}(i) = \infty$ (o $t_{S^{*}} (i) = \infty$). Il seguente lemma afferma che $ALG1_{k}$ avvia ogni job prima o allo stesso momento rispetto a $CHOP$.\newline\newline
\textbf{Lemma 2} 
\textit{Per qualsiasi job $i$, $t_{S}(i) \leq t_{S^{*}}(i)$.}\newline\newline
\textit{Dimostrazione}
La disuguaglianza vale ovviamente per i job che non sono mai stati schedulati da $CHOP$. Supponiamo che il lemma non valga per ogni job e sia $i$ quello che si trova per primo in $S^{*}$ con $t_{S^{*}}(i) < t_{S}(i)$. Sia $t^{*} = t_{S^{*}} (i)$ e sia $P_{n}$ la fase contenente $t^{*}$. Inoltre, sia il job $j$ quello schedulato da $ALG1_{k}$ al tempo $t^{*}$. In $I_{k}$ i job arrivano solo all'inizio di una fase, ovvero quando $ALG1_{k}$ prende le decisioni di scheduling. Quindi all'inizio di $P_{n}$ il job $i$ è arrivato e può essere schedulato da $ALG1_{k}$. Dal momento che $ALG1_{k}$ ordina i job disponibili in ordine di valore unitario non crescente e non esegue il job $i$ prima o allo stesso tempo di $t^{*}$, allora vale $v_{j} \geq v_{i}$ . 

Dimostriamo adesso che al tempo $t^{*}$, $CHOP$ ha già terminato il job $j$. Questo vale chiaramente se $v_{j} > v_{i}$ perché $CHOP$ schedula sempre un job non terminato con il valore unitario più alto. Se $v_{j} = v_{i}$, allora di nuovo $CHOP$ deve aver già completato il job $j$ perché in $S^{*}$ i job di valore unitario $v = v_{j} = v_{i}$ si verificano nello stesso ordine come in $S$ e il job $j$ precede il job $i$ in $S$. 

Poiché $CHOP$  al tempo $t^{*}$ ha già terminato il job $j$,  allora il tempo di inizio di $j$ è minore o uguale a $t - l_{j}$. D'altra parte $ALG1_{k}$ non ha avviato il job $j$ prima del tempo $t - l_{j} + 1$ perché lo sta ancora elaborando. Concludiamo che $t_{S^{*}}(j) < t_{S}(j) \leq t_{S^{*}}(i)$, il che contraddice l'assunzione che il job $i$ sia il primo in $S^{*}$ violando la disuguaglianza desiderata. \hfill $\square$ \vspace{5mm} 

Il lemma successivo mette in relazione il valore di $ALG1_{k}$ con quello di OPT, ottenuti con input $I_{k}$ . \newline\newline
\textbf{Lemma 3} 
\textit{$\forall k \in \N$ e $\forall \beta$, vale la disuguaglianza $1/(1-\beta^{k} ) \cdot ALG1_{k}(I_{k}) \geq OPT(I_{k})$.}\newline\newline
\textit{Dimostrazione}
Per qualsiasi $n \geq 1$, sia $I_{n}$ l'insieme dei job schedulati da $ALG1_{k}$ durante la fase $P_{n}$, cioè, formalmente $$I_{n} = \{i\;| \; (n - 1)k \leq t_{S}(i) \leq nk - 1\}.$$ Sia $ALG1_{k}(P_{n})$ il valore ottenuto da $ALG1_{k}$ nello scheduling dei job di $I_{n}$ e sia $CHOP(P_{n})$ il valore ottenuto da $CHOP$ nell'elaborazione di questi job. Vale quindi $ALG1_{k}(I_{k}) = \sum_{n} ALG1_{k}(P_{n})$. Una conseguenza del Lemma 2 è che tutti i job che sono stati schedulati da $CHOP$ sono presenti anche nello schedule di $ALG1_{k}$. Quindi $CHOP(I_{k}) = \sum_{n} CHOP(P_{n})$. Mostreremo che, $\forall n \in \N$, vale la disuguaglianza $CHOP(P_{n})/ALG1_{k} (P_{n}) \leq 1/(1 - \beta^{k})$. Questo implica che $CHOP(I_{k})/ALG1_{k} (I_{k} ) \leq 1/(1 - \beta^{k})$ e il lemma poi segue in quanto $CHOP(I_{k}) \geq OPT(I_{k})$. 

Consideriamo una qualsiasi $k$-fase $P_{n}$. Nello schedule $S$ sia $j$ l'ultimo job iniziato in $P_{n}$ e sia $\lambda_{j}$ il numero di unità di tempo per le quali $j$ è schedulato in $P_{n}$ e quindi nell'intero schedule $S$. Dal Lemma 2, per qualsiasi job $i$, vale $t_{S}(i) \leq t_{S^{*}}(i)$. Quindi il valore totale ottenuto da $CHOP$ nello schedulare i job $i \in I_{n}$ con $i \neq j$, così come le prime $\lambda_{j}$ unità di tempo del job $j$ non può essere superiore ad $ALG1_{k}(P_{n})$. 

Se il job $j$ viene pre-abbandonato in $S$ alla fine di $P_{n}$, allora $CHOP$ può ottenere un ulteriore valore aggiuntivo nello schedulare le rimanenti unità di tempo $\lambda_{j + 1},...\,, l_{j}$ del job $j$ in $S$. Anche in questo caso, poiché $t_{S}(j) \leq t_{S^{*}}(j)$, queste unità non possono essere sequenziate prima dell'inizio della fase $P_{n+1}$, cioè al tempo $nk$. Quindi il valore addizionale ottenibile per le unità $\lambda_{j + 1},...\,,l_{j}$ è limitato superiormente da $\sum_{t=nk}^{\infty} \beta^{t} v_{j} = \beta^{nk}/(1 - \beta ) \cdot v_{j}$, che è ottenuto schedulando un job di valore unitario $v_{j}$ di infinita lunghezza a partire dal tempo $nk$. 

Quindi $CHOP(P_{n}) \leq ALG1_{k}(P_{n})+\beta^{nk}/(1-\beta ) \cdot v_{j}$. In ciascuna fase $ALG1_{k}$ ordina i job in ordine di valore unitario non crescente. Di conseguenza ogni job di $I_{n}$ ha un valore unitario di almeno $v_{j}$. Concludiamo che valgono $ALG1_{k}(P_{n}) \geq \sum^{nk-1}_{t=(n-1)k} \beta^{t} v_{j} = (\beta^{(n-1)k} - \beta^{nk})/(1 -\beta ) \cdot v_{j}$ e $CHOP(Pn)/ALG1_{k}(P_{n}) \leq 1 + \beta^{nk}/(\beta^{(n-1)k} - \beta^{nk} ) = 1/(1 - \beta^{k})$. \hfill $\square$ \vspace{5mm}

Adesso possiamo dimostrare il Teorema 1.\newline \newline
\textit{Dimostrazione del Teorema 1} Combinando i lemmi 1 e 3 si ottiene che, $\forall k \in \N$ e $\forall \beta$ , vale la disuguaglianza $1/(\beta^{k-1}(1 - \beta^{k}))ALG1_{k}(I_{k}) \geq OPT(I)$ per ogni input $I$. Il teorema segue poiché vale $ALG1_{k}(I) = ALG1_{k}(I_{k})$.\hfill $\square$ \vspace{5mm}

Determiniamo il miglior valore di k.\newline \newline
\textbf{Corollario 1} 
\textit{Per $k = \lceil-log_{\beta} 2\rceil$, l'algoritmo risultante $ALG1_{k}$ è $4 / (2 - \beta )$-competitivo.} \newline\newline
\textit{Dimostrazione}
La funzione $f(x) = \beta^{x - 1}(1 - \beta^{x})$ è massimizzata per $x^{*} := - log_{\beta}2$. Scegliendo $k = \lceil-log_{\beta} 2\rceil$ si ottiene che $x^{*} \leq k \leq x^{*} + 1$ e $f (x^{*}) \geq f (k) \geq (2 - \beta )/4 = f (x^{*} + 1)$ in quanto $f(x)$ è strettamente decrescente per $x > x^{*}$. Il corollario è dimostrato, in quanto la competitività di $ALG1_{k}$ è $1 / f (k)$.\hfill $\square$ \vspace{5mm}

Il teorema che segue dimostra che il rapporto competitivo di $ALG1_{k}$ mostrato sopra non può essere più piccolo.\newline\newline
\textbf{Teorema 2}
\textit{$\forall k \in \N$ e $\forall \beta$, il rapporto competitivo di $ALG1_{k}$ non è inferiore a $1 / (\beta^{k - 1} (1 - \beta^{k}))$.}\newline\newline
\textit{Dimostrazione}
Supponiamo che $ALG1_{k}$ abbia ottenuto un rapporto competitivo $c < 1 / (\beta^{k - 1} (1 - \beta^{k}))$. Esiste quindi una costante $\alpha$ tale che vale $c \cdot ALG1_{k}(I) + \alpha \geq OPT (I)$ per ogni input $I$. Consideriamo un input specifico $I$ costituito da un singolo job che arriva al tempo 1,  che ha un valore di $v = \alpha / (\beta  (1 - c \beta^{k - 1} (1 - \beta^{k}))$ e lunghezza infinita. $ALG1_{k}$ avvia questo job al tempo $k$ e lo elabora per $k$ unità di tempo in modo che valga $ALG1_{k}(I) = \beta^{k} (1 - \beta^{k}) / (1 - \beta ) \cdot v$. D'altra parte $OPT (I) = \beta  / (1 - \beta ) \cdot v$. Quindi $$c \cdot ALG1_{k}(I) + \alpha = c \cdot ALG1_{k}(I) + (\alpha / v) v = c \cdot ALG1_{k}(I) + \beta  (1 - c\beta^{k - 1} (1 - \beta^{k})) v $$ $$< c \cdot ALG1_{k}(I) + \frac{\beta}{ 1 - \beta} (1 - c\beta^{k - 1} (1 - \beta^{k})) v = \frac{\beta}{1 - \beta} \cdot v = OPT(I),$$dove la disuguaglianza vale in quanto $1 - \beta  <1$. Abbiamo ottenuto una contraddizione. \hfill $\square$ \vspace{5mm}

Infine in questa sezione consideriamo l'algoritmo $ALG1_{1}$ in cui la lunghezza della fase $k$ è uguale a 1. Questo algoritmo schedula in qualsiasi momento un job con il valore per unità più elevato tra i job disponibili. Questo job viene elaborato per una sola unità di tempo. \newline\newline
\textbf{Corollario 2}
\textit{$\forall \beta$, il rapporto competitivo di $ALG1_{1}$ è esattamente $1 / (1 - \beta)$.}\newline\newline
\textit{Dimostrazione}
Il teorema 1 implica che $ALG1_{1}$ è $1 / (1 - \beta )$-competitivo. Inoltre per il Teorema 2 tale rapporto competitivo non può essere più piccolo. \hfill $\square$ \vspace{5mm}

Combiniamo infine i Corollari 1 e 2 per ottenere il seguente risultato.\newline\newline
\textbf{Corollario 3}
\textit{Impostando $k = 1$ se $\beta  \leq 2/3$ e $k = \lceil- log_{\beta}2\rceil$ altrimenti, otteniamo un algoritmo $ALG1_{k}$ che ottiene un rapporto competitivo di $min\{1 / (1 - \beta ), 4 / (2 - \beta )\}$.}\newline\newline
\textit{Dimostrazione}
Osserviamo che $1 / (1 - \beta ) \leq 4 / (2 - \beta )$ è vero se e solo se $\beta  \leq 2/3$. Supponiamo che $\beta  \leq 2/3$. In questo caso l'algoritmo risultante $ALG1_{1}$ ottiente un rapporto competitivo di $1 / (1 - \beta ) \leq min \{1 / (1 - \beta ), 4 / (2 - \beta )\}$, cfr. Corollario 2. Adesso supponiamo che $\beta > 2/3$. Per il Corollario 1, l'algoritmo $ALG1_{k}$ con  $k = \lceil- log_{\beta}2\rceil$ raggiunge una competitività di $4 / (2 - \beta ) <min \{1 / (1 - \beta ), 4 / (2 - \beta )\}$. \hfill $\square$ 


\section{$ALG2_{k}$}
Il secondo algoritmo, chiamato $ALG2_{k}$, è una raffinazione di $ALG1_{k}$; il principio di funzionamento è praticamente lo stesso. L’unica differenza sta nel fatto che tenta di ripristinare l’esecuzione di un eventuale job in una fase $P_{n}$ se è stato pre-rilasciato nella fase immediatamente precedente $P_{n-1}$. Formalmente $ALG2_{k}$ funziona come segue. Se $n > 1$, sia $i$ il job che è stato pre-rilasciato nella fase $P_{n-1}$. A questo punto definiamo il job residuo $r = (a_{i}, v_{i}, l_{r})$; $l_{r}$ è la parte rimanente del job $i$ che dev’essere processata. Aggiungiamo $r$ a $Q_{n}$. $ALG2_{k}$ ordina e schedula i job di $Q_{n}$ nello stesso modo di $ALG1_{k}$. Sia $S’(P_{n})$ lo schedule ottenuto in questo modo. Se $S’(P_{n})$ non contiene $r$ allora $S’(P_{n})$ è lo schedule finale per la fase. Altrimenti, se $S’(P_{n})$ contiene $r$ e tale job è schedulato per $s$ unità di tempo al tempo t, allora $ALG2_{k}$ modifica $S’(P_{n})$ in modo da spostare il job $r$ all’inizio della fase. Nello specifico il tempo di inizio di ogni job appartenente a $S’(P_{n})$ e diverso da $r$, viene aumentato di $s$ unità di tempo, mentre il tempo di inizio di $r$ diventa $t = (n-1)k$. Questo è lo schedule finale di $ALG2_{k}$ per $P_{n}$.
Teorema 3
$\forall k \in \N$ e $\forall \beta$, l'algoritmo $ALG2_{k}$ raggiunge un rapporto competitivo di $1 / \beta^{k - 1} \cdot max \{1 / \beta^{k - 1}, 1 / (1 - \beta^{2k}), 1 + \beta^{3k} / (1 - \beta^{k})\}$.
Costruiamo le basi per poter dimostrare il Teorema 3. Rispetto alla dimostrazione del Teorema 1, l'analisi è più complessa perché dobbiamo occuparci dei ritardi subiti da ALG2k nello Step(2) quando si schedula una porzione di job $i_{n}$ all'inizio della fase $P_{n}$ e posticipando così l'inizio dei job con valori unitari più alti. Inoltre, al fine di raggiungere un piccolo rapporto competitivo, dobbiamo addebitare la perdita di un job pre-abbandonato in una fase a una o più fasi adiacenti.
Ancora una volta, per ogni input $I = (a_{i}, v{i}, l_{i})^{N}_{i = 1}$, consideriamo l'input k-quantizzato $I_{k} =(a_{i}, v_{i}, l_{i})^{N}_{i = 1}$, dove il tempo di arrivo di qualsiasi job $i$ è $a_{i} = k \lceil a_{i}/k \rceil$. Vale $ALG2_{k}(I_{k}) = ALG2_{k}(I)$ e, come mostrato nel Lemma 1, $1 / \beta^{k-1} OPT (I_{k}) \geq OPT(I)$.Confronteremo $ALG2_{k}(I_{k})$ con $CHOP(I_{k})$, dove $CHOP$ è l'algoritmo offline ottimale descritto in Sez. 3. Di nuovo, sia $S$ lo schedule calcolato da $ALG2_{k}$ per $I_{k}$ e sia $S^{*}$ lo schedule di CHOP per $I_{k}$. Analogamente a quanto detto nella Sez. 3 supponiamo, senza perdita di generalità, che in $S^{*}$ tutti i job con un determinato valore unitario $v$ siano elaborati nello stesso ordine in cui sono processati in $S$.
Al fine di valutare $ALG2_{k}(I_{k})$, definiamo uno schedule $S'$ che ci consente di provare un'affermazione analoga al Lemma 2 e, inoltre, di confrontare i valori unitari dei job schedulati in $S'$ e $S^{*}$. Per qualsiasi fase $P_{n}$, consideriamo lo schedule $S'(P_{n})$ calcolato durante lo Step(1) di $ALG2_{k}$. Se $n > 1$ e il job residuo $i^{r}_{n}$ è schedulato per $s^{r}_{n}$ unità di tempo a partire dal tempo $t^{r}_{n}$ in $P_{n}$, allora modifichiamo $S'(P_{n})$ schedulando il job originale $i_{n}$ per $s^{r}_{n}$ unità di tempo a partire dal tempo $t^{r}_{n}$. Da adesso in poi chiameremo questo schedule modificato come $S'(P_{n})$. Lo schedule $S$ è la concatenazione di $S(P_{n})$, per ogni $n \geq 1$.
In $S'(P_{n})$ i job sono sequenziati in ordine di valore unitario non crescente. Tra i job di valore unitario $v = v_{i_{n}}$, il job $i_{n}$ viene elaborato per primo. Lo schedule $S'(P_{n})$ differisce da $S(P_{n})$ solamente per il job $i_{n}$, in quanto in $S'(P_{n})$ viene sequenziato dopo quei job che hanno un valore unitario strettamente superiore a $v_{i_{n}}$. Ciascuno di questi job inizia e termina in $P_{n}$. Lo spostamento della porzione di job di $i_{n}$ non influisce sul relativo ordine dei job che hanno lo stesso valore per unità. Quindi in $S'$ e $S$, e quindi in $S'$ e $S^{*}$, i job con un determinato valore unitario $v$ occorrono nello stesso ordine. Notiamo che lo schedule $S'$ non è corretto in quanto un job $i_{n}$ può essere interrotto alla fine della fase $P_{n-1}$ e ripreso più tardi in $P_{n}$.
Per qualsiasi job $i$, sia $t_{S'}(i)$ il suo tempo di inizio in $S'$. Come al solito $t_{S}(i)$ e $t_{S^{*}}(i)$ denotano il tempo di inizio del job $i$ rispettivamente in $S$ e $S^{*}$. I job che non compaiono mai in uno schedule hanno un tempo di inizio infinito. In seguito, con il Lemma 5, proveremo un'affermazione corrispondente a quella di Lemma 2: per ogni job $i$, esiste $t_{S'}(i) \leq  t_{S^{*}}(i)$. Per provare questo lemma abbiamo bisogno del seguente lemma ausiliario che implica, in particolare, che ogni job venga interrotto al massimo una volta in $S'$. Il lemma sarà anche essenziale nella dimostrazione di Lemma 6.
Lemma 4
Se un job viene interrotto in $S'$, allora questa interruzione si verifica alla fine di una fase $P_{n-1}$ e il job è uguale a $i_{n}$, cioè quello elaborato per ultimo in $S(P_{n-1})$ e $S'(P_{n-1})$. Il job è schedulato di nuovo solo in $P_{n}$ e non si verificano ulteriori interruzioni in $S'$.

\section{$ALG(m)_{k}$}
Il terzo algoritmo, chiamato $ALG(m)_{k}$, crea uno schedule ottimale per ogni k-fase $P_{n}$ considerando m macchine parallele. Formalmente $ALG(m)_{k}$ funziona come segue. Di nuovo, sia $Q_{n}$ l’insieme dei jobs $i$ che sono arrivati entro l’inizio di $P_{n}$, cioè $a_{i} \leq (n - 1)k$, e che non sono stati schedulati nelle fasi precedenti $P_{1}, … , P_{n}$. Per ogni $t = (n-1)k, … , nk - 1$ $ALG(m)_{k}$ determina gli m jobs che hanno il più alto valore unitario tra i jobs di $Q_{n}$ che non hanno terminato al tempo t. Ognuno di questi è schedulato per una sola unità di tempo. Se un job era già stato schedulato al tempo $t-1$, allora viene assegnato alla stessa macchina al tempo $t$. Se, tra i jobs che non hanno terminato di $Qn$, l’m-esimo valore unitario più grande è $v$ ed esistono diversi jobs che hanno questo valore, allora viene data la precedenza a quei job che erano già stati schedulati precedentemente. I jobs non ancora iniziati invece vengono considerati in ordine crescente di tempo di arrivo. Se alla fine di $P_{n}$ ci sono jobs schedulati che non hanno terminato, vengono pre-rilasciati. $ALG(m)_{k}$ esegue questo schedule per $P_{n}$, ignorando i jobs che potrebbero arrivare durante la fase a tempi $t = (n-1)k + 1, …, nk - 1$.




\section{Bibliografia}
1. Dasgupta, A., Ghosh, A., Nazerzadeh, H., Raghavan, P.: Online story scheduling in web advertising.
In: Proceedings of the 20th annual ACM-SIAM symposium on discrete algorithms, pp. 1275–1284
(2009)

\begin{flushleft}
2. Sleator, D.D., Tarjan, R.E.: Amortized efficiency of list update and paging rules. Commun. ACM 28,
202–208 (1985)
\end{flushleft}
\end{document}